---
layout:     post
title:      转：基于web的资源视图（cpu、内存、流量）显示方案
date:       2012-09-27
tags: [cnblogs]
---
基于web的资源视图（cpu、内存、流量）显示方案 2012-08-08 12:35:55

本人第一次写blog，努力中。

言归正传。这篇博客完成的工作是在网页上以图表的方式，显示cpu、内存、流量等资源信息。先上一副效果图：

[<img src="http://img1.51cto.com/attachment/201208/122652236.png" alt="" width="650" border="0" />](http://img1.51cto.com/attachment/201208/122652236.png)

使用工具与环境：

web架构：基于python的django

画图工具：基于js的画图工具 highcharts 链接http://www.highcharts.com/

页面的基本显示由html代码负责，没啥可说的。html代码如下：

1. <!DOCTYPE html> 
1. <html lang="en"> 
1. <head> 
1.   <title>计算机资源视图</title> 
1.   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
1.   <link rel="stylesheet" type="text/css" href="/media/css/basic.css"/> 
1.   <script type="text/javascript" src="/media/js/jquery-1.4.2.min.js" ></script> 
1.   <script type="text/javascript" src="/media/jschart/highcharts.js"></script> 
1.   <script type="text/javascript" src="/media/jschart/modules/exporting.js"></script> 
1.   <script type="text/javascript" src="/media/mjs/physical.js"></script> 
1. </head> 
1. <body> 
1.  
1.    <!--  #charts --> 
1.    <charts> 
1.       
1.        主控节点 资源视图 
1.         
1.         
1.         
1.         
1.  
1.          <br style="clear:both"/> 
1.        
1.    </charts> 
1. </body> 
1. </html> 

画图主要是使用js代码，使用ajax机制定时异步获得数据，然后在图上添加数据点。每5秒添加一个新点。js代码如下：

1.         var chart_cpu; 
1.         var chart_mem; 
1.         var chart_rx;  
1.         var chart_tx;  
1.         var maxmem; 
1.         var mem; 
1.         var pre_cpu = 0 
1.         var pre_cpu_total = 0 
1.         var pre_rb = 0 
1.         var pre_tb = 0 
1.         var flag = 1 
1.       var timeout = 5000 
1.       //var para = window.location.search;       
1.         //更新 
1.         function requestData() { 
1.          var stime = new Date(); 
1.             $.ajax({ 
1.             //async: false, 
1.                 url:'/ajax/jsonmgt',  
1.                 success: function(point) {               
1.                // add 4 points 
1.                var x = (new Date()).getTime() + 8*3600*1000; // 当前时间  
1.                var out = eval("(" + point + ")") 
1.                //var out = eval( point ) 
1.                maxmem = out[0] 
1.                mem = out[1] 
1.                cpu_use = out[2] 
1.                cpu_total = out[3] 
1.                rb = out[4] 
1.                tb = out[5] 
1.                memrate = mem/maxmem * 100 
1.                     //cpu 
1.                     d_cpu = cpu_use - pre_cpu 
1.                     d_cpu_total = cpu_total - pre_cpu_total 
1.                     pre_cpu = cpu_use 
1.                     pre_cpu_total = cpu_total 
1.                     cpurate = d_cpu/d_cpu_total *100 
1.                if(cpurate == 100) 
1.                   cpurate = 99.9 
1.                     //rb tb 
1.                     d_rb = rb - pre_rb 
1.                     d_tb = tb - pre_tb 
1.                     pre_rb = rb 
1.                     pre_tb = tb 
1.                     rkb = d_rb/1024 
1.                     tkb = d_tb/1024 
1.                     if(flag == 1){ 
1.                      rkb = 0 
1.                     tkb = 0 
1.                     cpurate = 0 
1.                         memrate = 0 
1.                     flag =0 
1.                     } 
1.                     //add points 
1.                chart_cpu.series[0].addPoint([x,cpurate], true, true); 
1.                chart_mem.series[0].addPoint([x,memrate], true, true); 
1.                chart_rx.series[0].addPoint([x,rkb], true, true); 
1.                chart_tx.series[0].addPoint([x,tkb], true, true); 
1.                var etime = new Date(); 
1.                d_date=etime.getTime()-stime.getTime(); 
1.                     setTimeout(requestData, timeout - d_date);   
1.                 }, 
1.                 cache: false 
1.             }); 
1.         } 
1.          
1. //cpu 
1. $(document).ready(function(){  
1.     chart_cpu = new Highcharts.Chart({  
1.         chart: {  
1.             renderTo: 'cpu', //图表放置的容器，DIV  
1.             defaultSeriesType: 'spline', //图表类型为曲线图  
1.             backgroundColor:'#DFFDFD', 
1.             events: {  
1.                 //load: requestData 
1.                                }  
1.                       },  
1.         title: {  
1.             text: 'CPU负载'      //图表标题  
1.                       },  
1.         xAxis: { //设置X轴  
1.             title: { text: '时间'   },   
1.             type: 'datetime',       //X轴为日期时间类型  
1.             tickPixelInterval: 150  //X轴标签间隔  
1.                       },  
1.         yAxis: { //设置Y轴  
1.             title: { text: 'CPU使用率'   }, 
1.             labels: { 
1.                   formatter: function() { 
1.                             return this.value +'%'; 
1.                               } 
1.                                  }, 
1.             max: 100, //Y轴最大值  
1.             min: 0  //Y轴最小值  
1.                       },  
1.         tooltip: {//当鼠标悬置数据点时的提示框  
1.             formatter: function() { //格式化提示信息  
1.                 return Highcharts.dateFormat('%H:%M:%S', this.x) +' '+   
1.                 Highcharts.numberFormat(this.y, 2)+'%';  
1.                                 }  
1.                       },  
1.         legend: {  
1.             enabled: false  //设置图例不可见  
1.                       },  
1.         exporting: {  
1.             enabled: false  //设置导出按钮不可用  
1.                       },  
1.         
1.         series: [{  
1.             data: (function() { //设置默认数据，  
1.                 var data = [],  
1.                 time = (new Date()).getTime() + 8*3600*1000,  
1.                 i;  
1.   
1.                 for (i = -19; i < 0; i++) {  
1.                     data.push({  
1.                         x: time + i * timeout,   
1.                         y: 0 * 100  
1.                                                       });  
1.                                            }  
1.                 return data;  
1.                                  })()  
1.                        }]  
1.            });  
1. });  
1. //mem 
1. $(function() {  
1.     chart_mem = new Highcharts.Chart({  
1.         chart: {  
1.             renderTo: 'mem', //图表放置的容器，DIV  
1.             defaultSeriesType: 'spline', //图表类型为曲线图  
1.             backgroundColor:'#DFFDFD', 
1.             events: {  
1.  
1.                                  }  
1.                       },  
1.         title: {  
1.             text: '内存负载'  //图表标题  
1.                       },  
1.         xAxis: { //设置X轴  
1.             title: { text: '时间'   },   
1.             type: 'datetime',  //X轴为日期时间类型  
1.             tickPixelInterval: 150  //X轴标签间隔  
1.                      },  
1.         yAxis: { //设置Y轴  
1.             title: { text: '内存使用记录'   }, 
1.             labels: { 
1.                   formatter: function() { 
1.                             return this.value + '%'; 
1.                               } 
1.                                  }, 
1.             max: 100, //Y轴最大值  
1.             min: 0  //Y轴最小值  
1.  
1.                       },  
1.         tooltip: {//当鼠标悬置数据点时的提示框  
1.             formatter: function() { //格式化提示信息  
1.                 return Highcharts.dateFormat('%H:%M:%S', this.x) +' '+   
1.                 Highcharts.numberFormat(this.y, 2) + '%' + ' ' + 
1.                      Highcharts.numberFormat(mem,0) + 'MB'; 
1.                                 }  
1.                       },  
1.         legend: {  
1.             enabled: false  //设置图例不可见  
1.                      },  
1.         exporting: {  
1.             enabled: false  //设置导出按钮不可用  
1.                      },  
1.         
1.         series: [{  
1.             data: (function() { //设置默认数据，  
1.                 var data = [],  
1.                 time = (new Date()).getTime()+8*3600*1000,  
1.                 i;  
1.   
1.                 for (i = -19; i < 0; i++) {  
1.                     data.push({  
1.                         x: time + i * timeout,   
1.                         y: 0  
1.                                                       });  
1.                                             }  
1.                 return data;  
1.                                  })()  
1.                       }]  
1.          });  
1. });  
1. //rx 
1. $(function() {  
1.     chart_rx = new Highcharts.Chart({  
1.         chart: {  
1.             renderTo: 'rx', //图表放置的容器，DIV  
1.             defaultSeriesType: 'spline', //图表类型为曲线图  
1.             backgroundColor:'#DFFDFD',   //背景颜色 
1.             events: {  
1.               
1.                                  }  
1.                       },  
1.         title: {  
1.             text: '网络接收流量'  //图表标题  
1.                      },  
1.         xAxis: { //设置X轴  
1.             title: { text: '时间'   },   
1.             type: 'datetime',  //X轴为日期时间类型  
1.             tickPixelInterval: 150  //X轴标签间隔  
1.                       },  
1.         yAxis: { //设置Y轴  
1.             title: { text: '接收网络流量'   }, 
1.             labels: { 
1.                   formatter: function() { 
1.                             return this.value +'kb/s'; 
1.                               } 
1.                                  }, 
1.             //max: 200, //Y轴最大值  
1.             min: 0  //Y轴最小值  
1.                       },  
1.         tooltip: {//当鼠标悬置数据点时的提示框  
1.             formatter: function() { //格式化提示信息  
1.                 return Highcharts.dateFormat('%H:%M:%S', this.x) +' '+   
1.                 Highcharts.numberFormat(this.y, 2)+'kb/s';  
1.                                 }  
1.                       },  
1.         legend: {  
1.             enabled: false  //设置图例不可见  
1.                       },  
1.         exporting: {  
1.             enabled: false  //设置导出按钮不可用  
1.                      },  
1.         
1.         series: [{  
1.             data: (function() { //设置默认数据，  
1.                 var data = [],  
1.                 time = (new Date()).getTime() + 8*3600*1000,  
1.                 i;  
1.   
1.                 for (i = -19; i < 0; i++) {  
1.                     data.push({  
1.                         x: time + i * timeout,   
1.                         y: 0  
1.                                                       });  
1.                                            }  
1.                 return data;  
1.                                 })()  
1.                      }]  
1.           });  
1. });  
1. //tx 
1. $(function() {  
1.     chart_tx = new Highcharts.Chart({  
1.         chart: {  
1.             renderTo: 'tx', //图表放置的容器，DIV  
1.             defaultSeriesType: 'spline', //图表类型为曲线图  
1.             backgroundColor:'#DFFDFD', 
1.             events: {  
1.                  load: requestData 
1.                                  }  
1.                       },  
1.         title: {  
1.             text: '网络发送流量'  //图表标题  
1.                      },  
1.         xAxis: { //设置X轴  
1.             title: { text: '时间'   },   
1.             type: 'datetime',  //X轴为日期时间类型  
1.             tickPixelInterval: 150  //X轴标签间隔  
1.                       },  
1.         yAxis: { //设置Y轴  
1.             title: { text: '发送网络流量'   }, 
1.             labels: { 
1.                   formatter: function() { 
1.                             return this.value +'kb/s'; 
1.                               } 
1.                                  }, 
1.             //max: 200, //Y轴最大值  
1.             min: 0  //Y轴最小值  
1.                       },  
1.         tooltip: {//当鼠标悬置数据点时的提示框  
1.             formatter: function() { //格式化提示信息  
1.                 return Highcharts.dateFormat('%H:%M:%S', this.x) +' '+   
1.                 Highcharts.numberFormat(this.y, 2)+'kb/s';  
1.                                 }  
1.                       },  
1.         legend: {  
1.             enabled: false  //设置图例不可见  
1.                       },  
1.         exporting: {  
1.             enabled: false  //设置导出按钮不可用  
1.                      },  
1.         
1.         series: [{  
1.             data: (function() { //设置默认数据，  
1.                 var data = [],  
1.                 time = (new Date()).getTime() + 8*3600*1000,  
1.                 i;  
1.   
1.                 for (i = -19; i < 0; i++) {  
1.                     data.push({  
1.                         x: time + i * timeout,   
1.                         y: 0 
1.                                                       });  
1.                                            }  
1.                 return data;  
1.                                 })()  
1.                      }]  
1.           });  
1. })

使用ajax，就需要有数据源定期提供数据。使用c语言写一个程序（取名mgtinfo.c）抓取瞬时的cpu、内存、流量。代码如下：

1. #include <stdlib.h> 
1. #include <stdio.h> 
1. #include <sys/stat.h> 
1. typedef struct        //定义一个cpu occupy的结构体 
1. { 
1.     char name[20];      //定义一个char类型的数组名name有20个元素 
1.     long user; //定义一个无符号的int类型的user 
1.     long nice; //定义一个无符号的int类型的nice 
1.     long system;//定义一个无符号的int类型的system 
1.     long idle; //定义一个无符号的int类型的idle 
1. }CPU_OCCUPY; 
1. typedef struct        //定义一个mem occupy的结构体 
1. { 
1.     char name[20];      //定义一个char类型的数组名name有20个元素 
1.     long total;  
1.     //char name2[20]; 
1.     char unit[20]; 
1.     long free; 
1.     long buffers;   
1.     long cached;                         
1. }MEM_OCCUPY; 
1. typedef struct        //定义一个cpu occupy的结构体 
1. { 
1.     char name[20];      //定义一个char类型的数组名name有20个元素 
1.     long rb, rpkt, r_err, r_drop, r_fifo, r_frame, r_compr, r_mcast;  
1.     long tb, tpkt, t_err, t_drop, t_fifo, t_coll, t_carrier, t_compr;  
1. }NET_OCCUPY; 
1. int get_memoccupy (MEM_OCCUPY *mem) //对无类型get函数含有一个形参结构体类弄的指针O 
1. { 
1.     FILE *fd;           
1.     int n;              
1.     char buf[256];    
1.     MEM_OCCUPY *m; 
1.     m=mem; 
1.      long MemFree, Buffers, Cached;                                                                                                     
1.     fd = fopen ("/proc/meminfo", "r");  
1.     fgets (buf, sizeof(buf), fd);  
1.     sscanf (buf, "%s %ld %s", &m->name, &m->total, &m->unit);  
1.     fgets (buf, sizeof(buf), fd);  
1.     sscanf (buf, "%s %ld %s", m->name, &m->free, m->unit);  
1.     fgets (buf, sizeof(buf), fd);  
1.     sscanf (buf, "%s %ld %s", m->name, &m->buffers, m->unit);  
1.     fgets (buf, sizeof(buf), fd);  
1.     sscanf (buf, "%s %ld %s", m->name, &m->cached, m->unit);  
1.     fclose(fd);     //关闭文件fd 
1.     return 0; 
1. } 
1. int get_cpuoccupy (CPU_OCCUPY *cpust) //对无类型get函数含有一个形参结构体类弄的指针O 
1. {    
1.     FILE *fd;          
1.     int n;             
1.     char buf[256];  
1.     CPU_OCCUPY *cpu_occupy; 
1.     cpu_occupy=cpust; 
1.           
1.      if ((fd = fopen ("/proc/stat", "r")) != NULL){  
1.             while (fgets (buf, sizeof(buf), fd)){  
1.                 if( *buf == 'c' && *(buf + 1) == 'p') break;  
1.                 }  
1.            fclose (fd);  
1.       }  
1.     else    
1.          printf("read file failed\n");                                                                                              
1.     sscanf (buf, "cpu %ld %ld %ld %ld", &cpu_occupy->user, &cpu_occupy->nice,&cpu_occupy->system, &cpu_occupy->idle); 
1.      //printf("%ld\n", cpu_occupy->user); 
1.      return 0;     
1. } 
1.  
1. int get_netoccupy (NET_OCCUPY *net) //对无类型get函数含有一个形参结构体类弄的指针O 
1. { 
1.     FILE *fd;                     
1.     char buf[256];    
1.     NET_OCCUPY *net_occupy; 
1.     net_occupy = net; 
1.      //long MemFree, Buffers, Cached; 
1.                                                                                                                
1.     fd = fopen ("/proc/net/dev", "r");  
1.        
1.     fgets (buf, sizeof(buf), fd);  
1.     fgets (buf, sizeof(buf), fd);  
1.     fgets (buf, sizeof(buf), fd);  
1.     fgets (buf, sizeof(buf), fd);  
1.     //printf("%s",buf); 
1.     sscanf (buf, "%s %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld", &net_occupy->name, &net_occupy->rb ,&net_occupy->rpkt, &net_occupy->r_err, &net_occupy->r_drop, &net_occupy->r_fifo ,&net_occupy->r_frame, &net_occupy->r_compr, &net_occupy->r_mcast, &net_occupy->tb, &net_occupy->tpkt); 
1.     fclose(fd);     //关闭文件fd 
1.     return 0; 
1. } 
1. int cal_cpuoccupy (CPU_OCCUPY *o, CPU_OCCUPY *n)  
1. {    
1.     unsigned long od, nd;     
1.     unsigned long id, sd; 
1.     int cpu_use = 0;    
1.     od = (unsigned long) (o->user + o->nice + o->system +o->idle);//第一次(用户+优先级+系统+空闲)的时间再赋给od 
1.     nd = (unsigned long) (n->user + n->nice + n->system +n->idle);//第二次(用户+优先级+系统+空闲)的时间再赋给od  
1.     id = (unsigned long) (n->user - o->user);    //用户第一次和第二次的时间之差再赋给id 
1.     sd = (unsigned long) (n->system - o->system);//系统第一次和第二次的时间之差再赋给sd 
1.     if((nd-od) != 0) 
1.     cpu_use = (int)((sd+id)*10000)/(nd-od); //((用户+系统)乖100)除(第一次和第二次的时间差)再赋给g_cpu_used 
1.     else cpu_use = 0; 
1.     return cpu_use; 
1. } 
1. int main() 
1. { 
1.     CPU_OCCUPY cpu_stat; 
1.     MEM_OCCUPY mem_stat; 
1.     NET_OCCUPY net_stat; 
1.     long cpu_use, cpu_total; 
1.     //获取内存 
1.     get_memoccupy ((MEM_OCCUPY *)&mem_stat); 
1.     //第一次获取cpu使用情况 
1.     get_cpuoccupy((CPU_OCCUPY *)&cpu_stat); 
1.      cpu_use = cpu_stat.user + cpu_stat.nice + cpu_stat.system; 
1.      cpu_total=cpu_stat.user + cpu_stat.nice + cpu_stat.system + cpu_stat.idle; 
1.     //printf("%ld,%ld,%ld,%ld\n",cpu_stat.user,cpu_stat.nice,cpu_stat.system,cpu_stat.idle); 
1.      get_netoccupy((NET_OCCUPY *)&net_stat); 
1.     printf("%ld,%ld,%ld,%ld,%ld,%ld\n",mem_stat.total/1024,(mem_stat.total-mem_stat.free-mem_stat.buffers-mem_stat.cached)/1024,cpu_use,cpu_total,net_stat.rb,net_stat.tb);   
1.     return 0; 
1. }  

在django中，需要写一个函数jsonmgt，作为ajax请求的响应。每次执行，jsonmgt调用mgtinfo.c，获得瞬时cpu、内存、流量后，以json数据形式返回给页面。页面再用上面贴的js代码添加数据点绘图。

1. # time data 
1. def jsonmgt( request ): 
1.     print "calulate data" 
1.     cmd="cmd/./mgtinfo"  
1.     output = os.popen(cmd,'r') 
1.     ret = output.read() 
1.     info = ret.split(',') 
1.     maxmem = string.atof(info[0]) 
1.     mem = string.atof(info[1]) 
1.     cpu_use = string.atof(info[2]) 
1.     cpu_total = string.atof(info[3]) 
1.     rb = string.atof(info[4]) 
1.     tb = string.atof(info[5]) 
1.     output.close() 
1.     data = [maxmem,mem,cpu_use,cpu_total,rb,tb] 
1.     data = simplejson.dumps( data, cls = QuerySetEncoder ) 
1.     return HttpResponse( data ) 
1. # django ajax 
1. class QuerySetEncoder( simplejson.JSONEncoder ): 
1.     """ 
1.         Encoding QuerySet into JSON format. 
1.     """ 
1.     def default( self, object ): 
1.         try: 
1.             return serializers.serialize( "python", object,ensure_ascii = False ) 
1.         except: 
1.             return simplejson.JSONEncoder.default( self, object ) 

本文出自 [说话的白菜](http://speakingbaicai.blog.51cto.com) 博客，请务必保留此出处[http://speakingbaicai.blog.51cto.com/5667326/958314](http://speakingbaicai.blog.51cto.com/5667326/958314)
